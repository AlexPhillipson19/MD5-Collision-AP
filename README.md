CSE 4400 - Project 1 - Alex Phillipson - 16 February 2023

In this lab, we will examine certain properties of hash functions, including collision resistance, as well as the one-way property.  This will allow us to understand the importance of collision-resistance and the like, and realize what possible damages can occur if this is not implemented. To do this, we will be launching prepared collision attacks against the MD5 hash function. The end goal of these attacks is to have two different programs that have the same MD5 hash. That is, these actions would theoretically trick a victim into downloading a malicious file that is different from their intended download, despite appearing "safe" due to having the "correct" MD5 hash.

Task 1: Generating two different files that have the same MD5 hash values
Using: MD5 Collision Generator by Marc Stevens

#Created a test file "test1.txt" with the contents "Hello there.", then ran md5collgen on it.
$ md5collgen -p test1.txt -o test1out1.bin test1out2.bin
#I then ran the commands diff, as well as md5sum, on the outputted files.

#3.1 collgen and diff.PNG
#3.1 md5sum.PNG

As you can see, the files have the same MD5 hash, despite being different files. Looking into the files with bless also illustrates that they are different files.

#3.1 bless1.PNG
#3.1 bless2.PNG

QUESTION 1: If the length of your prefix file is not multiple of 64, what is going to happen?

If the length is not a multiple of 64, then the file will be padded with zeroes, as shown in the bless readouts. This is because MD5 processes files in block sizes of 64.


QUESTION 2:  Create a prefix file with exactly 64 bytes, and run the collision tool again, and see what
happens.

To do this, I used the truncate command. Specifically:

$ truncate -s 64 trunctest.txt

#3.1 q2 truncate.PNG

whoops, i mis-typed the md5collgen part. Here is the correct command.

#3.1 q2 truncate fixed.PNG

It is noticed that this time, there is no zero padding.

#3.1 q2 bless.PNG

QUESTION 3: Are the data (128 bytes) generated by md5collgen completely different for the two
output files? Please identify all the bytes that are different.

No, the data generated by md5collgen is not completely different for the two output files. Noticeably, only 5 bytes are changed in this past example, highlighted in the following pictures.

#3.1 q3 difference.PNG
#3.1 q3 difference 2.PNG


Task 2: Understanding MD5's Property

In this task, I need to design an experiment to demonstrate the following property of MD5 hash:

"Given two inputs M and N, if MD5(M) = MD5(N), i.e., the MD5 hashes of M and N are the same, then for any input T, MD5(M I T) = MD5(N I T), where I represents concatenation. That is, if inputs M and N have the same hash, adding the same suffix T to them will result in two outputs that have the same hash value."

Luckily, this is easier than it sounds. MD5 hash is subject to length extension, which basically means that the function uses compression to process the messages in fixed blocks. In other words, after appending a file, the compression algorithm would be ran on the previous block as well as the current one. This hash would then be identical. Let's show it down below.

#3.2 part1.PNG
^in that picture, it is shown that we created a file, ran md5collgen on it, and verified that the hashes are identical.

Now, we will append a random string to the end of the file and reverify that the hashes are still identical to each other, though different from before.

#3.2 part2.PNG


Task 3: Generating Two Executable Files with the Same MD5 Hash

For this part, we will create two different versions of a program, such that the contents of their xyz arrays are different, but the hash values of the executables are the same. This is using the provided c code from the assignment PDF.

I used bless to find the location of the string of "AAAAAAA . . . AAAAA", but unfortunately the location was not divisible by 64. Remember that MD5 uses block sizes of 64, so this was crucial.

Here is the screenshot for that bless readout.

#3.3 bless.PNG

I then manually adjusted my calculations by adding until I reached a number divisible by 64, in this case 12352. This became the head, or p, as shown in the following screenshot. To get the tail, or q, I added 128 to that number, to get a position of 12480. Finally, I put the two together, and then ran the MD5 hash function on them. The output was the same for both files, as expected, proving our task.

#3.3.PNG

TASK 4: Making the Two Programs Behave Differently

In this task, we will create two programs that share the same MD5 hash. However, one program will always execute benign instructions, while the other program will execute malicious instructions. This is demonstrating that while two executable programs can have the same MD5 hash, they can behave completely differently. This represents a security vulnerability.

Thought process:
Use task4.o to create prefix and suffix files. #12608->12641

Prefix goes to location 12352 (12321 -> 12352), need divisible by 64 number
Suffix goes from location 12480 (12352 + 128)
^Obtained by looking at task4.o in bless

suffix y-array start location: 161
#task4 suffix location.PNG

tail start: 161+128=289

Eventually, the hashes for the two files were the same, but the output was different! This can have severe ramifications if malicious code was used in place of "Virus". Here's my terminal feed of my actions, with some relevant notations.

#task4 beginning.PNG

#task4 end.PNG

As you can see, there have been two new files created, that have the same checksum, and yet the outputs are different. That concludes the fourth task of this project.


-----------------------------------------

CONCLUSION

This project demonstrates several key observations about hash functions, specifically MD5, and potential vulnerabilities. It also demonstrates how, while powerful, collision resistance and one-way hash functions are not foolproof, specically for MD5. Of course, nothing is realistically foolproof in cybersecurity, but some methods have more vulnerabilities than others. It is important to note the limitations of the tools you are using when considering your cybersecurity goals.
